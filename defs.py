import numpy as np

# Overall size of box to generate path in
SIZE_X = 180
SIZE_Y = 100
SIZE_Z = 180

BASE_OF_MODEL = -10 # Offset from 0 in Z to print main body off of
BASE_THICKNESS = 4 # Offset from 0 in Z to print main body off of

PT_SPACING = 5 # distance from one point to the next

PT_DROP = 0.9 # target z drop per pt
POINT_COUNT = int(np.floor(SIZE_Z / PT_DROP)) # Total number of path points

PATH_COUNT = 4 # Numer of paths to generate

# Path gen optimization
PATH_ITERS = 500 # Number of iterations to optimize too
RESAMPLE_AT = [] # Resample the path to alleviate knots at this number of iterations
APPLY_FORCES_SEPARATELY = True
SET_ITERATION_MOVE_DISTS = False # Move all points by same distance which gradually decreases (instead of by force)
LESS_RANDOM_INIT_PATH = False # Generate initial paths by interpolating between a few random paths (instead of randomizing every point)
RANDOM_CNT = 15 # How many random points to generate if LESS_RANDOM_INIT_PATH

LOCKED_PT_CNT = 5 # Points locked in a straight line as part of the initial path

# Track defs
MARBLE_RAD = 6.3/2 # Radius of marble
TRACK_RAD = 0.75 # Radius of standard marble support section

TRACK_CONTACT_ANGLE = np.pi/6 # Angle between path and support points
TRACK_MAX_TILT = np.pi/4 # Max angle of tilt for track
SMOOTH_TILT_CNT_A = 2 # How many points to smooth each rotation points' tilt by
SMOOTH_TILT_CNT_B = 3 # And then we do it again

# Support generation constants
TRACK_SUPPORT_RAD = 0.75 # Initial radius of track support
TRACK_SUPPORT_MAX_RAD = 2.0 # Maximum support radius
SUPPORT_LAYER_HEIGHT = 0.25 # Layer height
MAX_PARTICLE_VEL = SUPPORT_LAYER_HEIGHT*2.0 # Maximum XY motion between each layer
MAX_PARTICLE_ACC = SUPPORT_LAYER_HEIGHT*2 # Maximum XY acceleration between each layer (except in case of emergency to avoid collision)
MERGE_RAD = MAX_PARTICLE_VEL # Radius to merge points beneath
MERGE_SMOOTH_PTS = 8 # How many points to start resizing column before join

PARTICLE_DRAG = 0.85 # Fraction of velocity retained across frames
SUPPORT_ATTRACTION_CONSTANT = 50.0 # Constant multiplier for attraction force between particles
SUPPORT_MAX_ATTRACTION_DIST = 100 # DISABLED max attraction distance
SUPPORT_BOUNDARY_FORCE_MAG = 10.0 # Force of boundary limitation, in force/mm

# Support avoidPt constants
PEAK_REPULSION_MAG = 4.0 # Maximum force generated by point avoidance
Z_DIFF_MIN = MARBLE_RAD*3 # Z difference of min repulsion force
Z_DIFF_MAX = 15 # Z difference of max repulsion force
POS_DIFF_MIN = MARBLE_RAD*1.5 # min XY diff of repulsion force
POS_DIFF_MAX = MARBLE_RAD*3 # max XY diff of repulsion force

PULL_TO_CENTER_MAG = 1.5

REALTIME_PLOTTING_FORCEMAGS = False
REALTIME_PLOTTING_PATHS = False
SUPPORT_VIS = True # Output support gen visualization
GENERATE_SUPPORTS = True
LOAD_EXISTING_PATH = False

UNIVERSAL_FN = 6 # How many sides for each triangle
HIGHER_RES_FN = 20

# Screw lift
SCREW_RAD = 12 # Center of rotation to center of marble on track
SCREW_PITCH = 16 # mm per rev
SCREW_RESOLUTION = 30 # pts per rev
SCREW_SUPPORT_GROUPING = (4, 9)
SCREW_OUTER_TRACK_DIST = 0.5 # How far out to place the bottom rail
SCREW_TOP_PUSH_PTS = 10 # How many points at the top of the screw to push towards the outside

# Entry and exit connections
END_PATH_OFFSET = MARBLE_RAD * (1 + np.sin(TRACK_CONTACT_ANGLE))
SCREW_VERT_RAIL_MARGIN = 0.0 # Margin between bottom rail and vertical lift supports

MOTOR_TYPE = 'SMALL_DC'
MOTOR_TYPE = 'NEMA17'

SCREW_POS = np.array([SIZE_X/2, SIZE_Y/2, 0.0])

WORKING_DIR = 'proc/Print7v2/'

BOUNDING_BOX = np.array([SIZE_X, SIZE_Y, SIZE_Z])


ABSOLUTE_MIN_PATH_DIST = (MARBLE_RAD + TRACK_RAD)
ABSOLUTE_MIN_PT_DIST = np.sqrt(np.square(2*ABSOLUTE_MIN_PATH_DIST) + np.square(PT_SPACING/2))
