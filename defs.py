import numpy as np

# Overall size of box to generate path in
SIZE_X = 120
SIZE_Y = 195
SIZE_Z = 40

BASE_OF_MODEL = -10 # Offset from 0 in Z to print main body off of

PT_SPACING = 6 # distance from one point to the next

PT_DROP = 1.5 # target z drop per pt
POINT_COUNT = int(np.floor(SIZE_Z / PT_DROP)) # Total number of path points

PATH_COUNT = 1 # Numer of paths to generate

# Path gen optimization
PATH_ITERS = 150 # Number of iterations to optimize too
RESAMPLE_AT = [75] # Resample the path to alleviate knots at this number of iterations
SET_ITERATION_MOVE_DISTS = False # Move all points by same distance which gradually decreases (instead of by force)
LESS_RANDOM_INIT_PATH = True # Generate initial paths by interpolating between a few random paths (instead of randomizing every point)
RANDOM_CNT = 10 # How many random points to generate if LESS_RANDOM_INIT_PATH

INIT_PATH_PTS = POINT_COUNT # Optionally generate end of path gradually instead of starting with full set
LOCKED_PT_CNT = 3 # Points locked in a straight line as part of the initial path

# Track defs
MARBLE_RAD = 6.3/2 # Radius of marble
TRACK_RAD = 0.75 # Radius of standard marble support section

TRACK_CONTACT_ANGLE = np.pi/4 # Angle between path and support points
TRACK_MAX_TILT = np.pi - TRACK_CONTACT_ANGLE # Max angle of tilt for track
SMOOTH_TILT_CNT = 5 # How many points to smooth each rotation points' tilt by

# Support generation constants
TRACK_SUPPORT_RAD = 0.75 # Initial radius of track support
TRACK_SUPPORT_MAX_RAD = 2.0 # Maximum support radius
SUPPORT_LAYER_HEIGHT = 1.0 # Layer height
MAX_MOVE_PER_LAYER = SUPPORT_LAYER_HEIGHT # Maximum XY motion between each layer
MERGE_RAD = MAX_MOVE_PER_LAYER*2 # Radius to merge points beneath
MERGE_SMOOTH_PTS = 8 # How many points to start resizing column before join

SUPPORT_ATTRACTION_CONSTANT = 1.0
SUPPORT_MAX_ATTRACTION_DIST = 100 # DISABLED max attraction distance
SUPPORT_BOUNDARY_FORCE_MAG = 10.0 # Force of boundary limitation, in force/mm

# Support avoidPt constants
PEAK_REPULSION_MAG = 1 # Maximum force generated by point avoidance
Z_DIFF_MIN = 20 # Z difference of min repulsion force
Z_DIFF_MAX = 60 # Z difference of max repulsion force
POS_DIFF_MIN = 4 # XY diff of min repulsion force
POS_DIFF_MAX = 10 # XY diff of max repulsion force


SUPPORT_VIS = False # Output support gen visualization
UNIVERSAL_FN = 10 # How many sides for each triangle

# Screw lift
SCREW_RAD = 16 # Center of rotation to center of marble on track
SCREW_PITCH = 16 # mm per rev
SCREW_RESOLUTION = 30 # pts per rev
SCREW_SUPPORT_GROUPING = 5
SCREW_OUTER_TRACK_DIST = 0.0 # How far out to place the bottom rail
SCREW_TOP_PUSH_PTS = 10 # How many points at the top of the screw to push towards the outside

WORKING_DIR = 'proc/Test/'




BOUNDING_BOX = np.array([SIZE_X, SIZE_Y, SIZE_Z])

ABSOLUTE_MIN_PATH_DIST = (MARBLE_RAD + TRACK_RAD)
ABSOLUTE_MIN_PT_DIST = np.sqrt(np.square(2*ABSOLUTE_MIN_PATH_DIST) + np.square(PT_SPACING/2))
