import numpy as np
import sys

GLASS_MARBLE_14mm = False
WORKING_DIR = 'proc/Print22/'

if len(sys.argv) > 1 and sys.argv[1] != '-reset':
    WORKING_DIR = sys.argv[1]


# Overall size of box to generate path in
SIZE_X = 180
SIZE_Y = 105
SIZE_Z = 180

BASE_OF_MODEL = -10 # Offset from 0 in Z to print main body off of
BASE_THICKNESS = 6 # Offset from 0 in Z to print main body off of

PT_SPACING = 6 # distance from one point to the next

PT_DROP = 0.75    # target z drop per pt
INITIAL_POINT_MULT_SLOPE = 1.5*PT_DROP
POINT_COUNT = int(np.floor(SIZE_Z / PT_DROP)) # Total number of path points
if POINT_COUNT%2 == 0: POINT_COUNT += 1

PATH_COUNT = 7 # Numer of paths to generate
MIRROR_PATHS = False
if MIRROR_PATHS:
    SIZE_X = SIZE_Y


# Path gen optimization
PATH_ITERS = 10000 # Number of iterations to optimize too
RESAMPLE_AT = [] # Resample the path to alleviate knots at this number of iterations
APPLY_FORCES_SEPARATELY = True
SET_ITERATION_MOVE_DISTS = False # Move all points by same distance which gradually decreases (instead of by force)
LESS_RANDOM_INIT_PATH = True # Generate initial paths by interpolating between a few random paths (instead of randomizing every point)
RANDOM_CNT = 4 # How many random points to generate if LESS_RANDOM_INIT_PATH

# Path randomization
#   Based on max force mag, calculates temperature and temp decay
#   A positive temp indicates mag of random noise added
#   A negative temp indicates magnitude of force updates, with -10 being 0
#   Pairs are (max force mag, noise setting, temp decay)
DO_DYNAMIC_TEMPERATURE = True
TEMPERATURE_HISTORY_LEN = 400
TEMPERATURE_FAILURE_BOOST = 20.0
PATH_RANDOMIZATION_FUNC = np.swapaxes([
    [10.0, -10.0, 0.1],
    [13.0, 0.0, 0.05],
    [13.1, 1.0, 0.05],
    [17.0, 2.0, 0.1],
    [40.0, 15.0, 0.2],
    [200.0, 40.0, 0.5], # Max noise of 20
], 0, 1)

# PATH_RANDOMIZATION_FUNC[0] *= 1.6
# PATH_RANDOMIZATION_FUNC[0, 0] = 14

LOCKED_PT_CNT = 5 # Points locked in a straight line as part of the initial path

# Track defs
MARBLE_RAD = 6.3/2 # Radius of marble
TRACK_RAD = 1.2 # Radius of standard marble support section

if GLASS_MARBLE_14mm:
    PT_SPACING = 10.0
    MARBLE_RAD = 7.0
    TRACK_RAD = 1.5
    PATH_COUNT = 2
    PT_DROP = 0.8
    PATH_RANDOMIZATION_FUNC[1, 1:] /= 2

TRACK_CONTACT_ANGLE = np.pi/5 # Angle between path and contact points4
TRACK_MAX_TILT = np.pi/5 # Max angle of tilt for track
SMOOTH_TILT_CNT_A = 2 # How many points to smooth each rotation points' tilt by
SMOOTH_TILT_CNT_B = 3 # And then we do it again

# Support generation constants
TRACK_SUPPORT_RAD = 1.0 # Initial radius of track support
TRACK_SUPPORT_MAX_RAD = 2.2 # Maximum support radius
SUPPORT_LAYER_HEIGHT = 0.5 # Layer height
MAX_PARTICLE_VEL = SUPPORT_LAYER_HEIGHT*2.0 # Maximum XY motion between each layer
MAX_PARTICLE_ACC = SUPPORT_LAYER_HEIGHT*0.3 # Maximum XY acceleration between each layer (except in case of emergency to avoid collision)
MERGE_RAD = MAX_PARTICLE_VEL*MAX_PARTICLE_VEL # Radius to merge points beneath
MERGE_SMOOTH_PTS = 8 # How many points to start resizing column before join

PARTICLE_DRAG = 0.5 # Fraction of velocity retained across frames
SUPPORT_ATTRACTION_CONSTANT = 80.0 # Constant multiplier for attraction force between particles
SUPPORT_MAX_ATTRACTION_DIST = 50.0 # DISABLED max attraction distance
SUPPORT_BOUNDARY_FORCE_MAG = 20.0 # Force of boundary limitation, in force/mm

# Support avoidPt constants
PEAK_REPULSION_MAG = 5.0 # Maximum force generated by point avoidance
Z_DIFF_MIN = MARBLE_RAD*3 # Z difference of min repulsion force
Z_DIFF_MAX = MARBLE_RAD*6 # Z difference of max repulsion force
POS_DIFF_MIN = MARBLE_RAD*1.5 # min XY diff of repulsion force
POS_DIFF_MAX = MARBLE_RAD*2.5 # max XY diff of repulsion force
PATH_REPEL_DROP = MARBLE_RAD*2.0 # Drop points this far in Z from center of point

PULL_TO_CENTER_MAG = 0.0 # Magnitude of force pulling points to target radius
PULL_TO_CENTER_MAXDIST = 10.0 # Distance at which to cap pull to target rad

HOLLOW_SUPPORTS = True
SUPPORT_SIZE_INTERP = np.swapaxes([
    [1, 1.2],
    [2, 2.0],
    [10, 4.0]
], 0, 1)
SUPPORT_HOLLOW_INTERP = np.swapaxes([
    [1, 0.0],
    [2, 0.8],
    [6, 2.0],
    [15, 3.2]
], 0, 1)
SUPPORT_BASE_RAD = 5

REALTIME_PLOTTING_FORCEMAGS = False

GENERATE_SUPPORTS = True
SUPPORT_VIS = True # Output support gen visualization

CONNECT_LIFTS = True
LIFT_SUPPORT_CROSSES = 5
LIFT_SUPPORT_SUBDIV = 11
LOAD_EXISTING_PATH = True

# How many sides for each circle
UNIVERSAL_FN = 6
HIGHER_RES_FN = 10

UNIVERSAL_FN = 16
HIGHER_RES_FN = 30

# Screw lift
SCREW_RAD = 12 # Center of rotation to center of marble on track
SCREW_PITCH = 16 # mm per rev
SCREW_RESOLUTION = 30 # pts per rev
SCREW_SUPPORT_GROUPING = (4, 9)
SCREW_OUTER_TRACK_DIST = 0.5 # How far out to place the bottom rail
SCREW_TOP_PUSH_PTS = 15 # How many points at the top of the screw to push towards the outside


if GLASS_MARBLE_14mm:
    SCREW_RAD = 16


# Entry and exit connections
END_PATH_OFFSET = MARBLE_RAD * (1 + np.sin(TRACK_CONTACT_ANGLE))
SCREW_VERT_RAIL_MARGIN = -0.15 # Margin between bottom rail and vertical lift supports

MOTOR_TYPE = 'SMALL_DC'
MOTOR_TYPE = 'NEMA17'

SCREW_POS = np.array([SIZE_X/2, SIZE_Y/2, 0.0])


BOUNDING_BOX = np.array([SIZE_X, SIZE_Y, SIZE_Z])
OUTPUT_BASE_RAD = np.min([SIZE_X, SIZE_Y]) / 2


ABSOLUTE_MIN_PATH_DIST = (MARBLE_RAD + TRACK_RAD)
ABSOLUTE_MIN_PT_DIST = np.sqrt(np.square(2*ABSOLUTE_MIN_PATH_DIST) + np.square(PT_SPACING/2))
